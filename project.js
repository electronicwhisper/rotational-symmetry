// Generated by CoffeeScript 1.6.3
(function() {
  var App, Canvas, Editor, EditorTool, Geo, LayerManager, Model, Ref, Render, makeElFromHTML, _base, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.App = App = (function() {
    function App() {
      new Editor();
    }

    return App;

  })();

  /*
  
  A Canvas manages the quirks of the browser canvas element. It also keeps track
  of the pan/zoom of the canvas by providing methods to convert from coordinate
  spaces.
  
  TODO: Move hit testing into Render.
  */


  Canvas = (function() {
    function Canvas(el) {
      this.el = el;
      this.ctx = this.el.getContext("2d");
      this.setupSize();
    }

    Canvas.prototype.width = function() {
      return this.el.width / this.ratio;
    };

    Canvas.prototype.height = function() {
      return this.el.height / this.ratio;
    };

    Canvas.prototype.setupSize = function() {
      var backingStoreRatio, devicePixelRatio, rect;
      devicePixelRatio = window.devicePixelRatio || 1;
      backingStoreRatio = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1;
      this.ratio = devicePixelRatio / backingStoreRatio;
      rect = this.el.getBoundingClientRect();
      this.el.width = rect.width * this.ratio;
      this.el.height = rect.height * this.ratio;
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      return this.ctx.scale(this.ratio, this.ratio);
    };

    Canvas.prototype.browserToCanvas = function(browserPoint) {
      var canvasPoint, rect, x, y;
      rect = this.el.getBoundingClientRect();
      x = browserPoint.x - rect.left;
      y = browserPoint.y - rect.top;
      return canvasPoint = new Geo.Point(x, y);
    };

    Canvas.prototype.browserToWorkspace = function(browserPoint) {
      var canvasPoint, workspacePoint;
      canvasPoint = this.browserToCanvas(browserPoint);
      return workspacePoint = this.canvasToWorkspace(canvasPoint);
    };

    Canvas.prototype.canvasToWorkspace = function(canvasPoint) {
      var workspacePoint, x, y;
      x = canvasPoint.x - this.width() / 2;
      y = canvasPoint.y - this.height() / 2;
      return workspacePoint = new Geo.Point(x, y);
    };

    Canvas.prototype.workspaceToCanvas = function(workspacePoint) {
      var canvasPoint, x, y;
      x = workspacePoint.x + this.width() / 2;
      y = workspacePoint.y + this.height() / 2;
      return canvasPoint = new Geo.Point(x, y);
    };

    Canvas.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width(), this.height());
    };

    Canvas.prototype.isObjectNearPoint = function(object, canvasPoint) {
      if (object instanceof Geo.Point) {
        return this.isPointNearPoint(object, canvasPoint);
      } else if (object instanceof Geo.Line) {
        return this.isLineNearPoint(object, canvasPoint);
      }
    };

    Canvas.prototype.isPointNearPoint = function(point, canvasPoint) {
      var distanceSquared, dx, dy;
      point = this.workspaceToCanvas(point);
      dx = point.x - canvasPoint.x;
      dy = point.y - canvasPoint.y;
      distanceSquared = (dx * dx) + (dy * dy);
      return distanceSquared < 15 * 15;
    };

    Canvas.prototype.isLineNearPoint = function(line, canvasPoint) {
      return false;
    };

    return Canvas;

  })();

  Editor = (function() {
    function Editor() {
      this.canvasPointerLeave = __bind(this.canvasPointerLeave, this);
      this.canvasPointerUp = __bind(this.canvasPointerUp, this);
      this.canvasPointerMove = __bind(this.canvasPointerMove, this);
      this.canvasPointerDown = __bind(this.canvasPointerDown, this);
      this.resize = __bind(this.resize, this);
      this.palettePointerDown = __bind(this.palettePointerDown, this);
      this.tool = new EditorTool.Select(this);
      this.contextWreath = null;
      this.movingPointRef = null;
      this.setupModel();
      this.setupLayerManager();
      this.setupPalette();
      this.setupCanvas();
    }

    Editor.prototype.setupModel = function() {
      var center, centerRef, rotation;
      this.model = new Model.Wreath();
      center = new Model.Point(new Geo.Point(0, 0));
      centerRef = new Ref(new Ref.Path([
        {
          wreath: this.model,
          op: 0
        }
      ]), center);
      rotation = new Model.RotationWreath(centerRef, 12);
      this.model.objects.push(rotation);
      this.contextWreath = rotation;
      return window.model = this.model;
    };

    Editor.prototype.setupLayerManager = function() {
      return this.layerManager = new LayerManager(this);
    };

    Editor.prototype.setupPalette = function() {
      var canvasEl, palette, toolEl, toolName, _i, _len, _ref;
      palette = document.querySelector("#palette");
      _ref = palette.querySelectorAll(".palette-tool");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        toolEl = _ref[_i];
        toolName = toolEl.getAttribute("data-tool");
        canvasEl = toolEl.querySelector("canvas");
        this.drawPaletteTool(toolName, canvasEl);
      }
      return palette.addEventListener("pointerdown", this.palettePointerDown);
    };

    Editor.prototype.drawPaletteTool = function(toolName, canvasEl) {
      var canvas, center, p1, p2, radiusPoint;
      canvas = new Canvas(canvasEl);
      if (toolName === "Select") {

      } else if (toolName === "LineSegment") {
        p1 = new Geo.Point(-10, -10);
        p2 = new Geo.Point(10, 10);
        Render.drawPoint(canvas, p1);
        Render.drawPoint(canvas, p2);
        return Render.drawLine(canvas, p1, p2);
      } else if (toolName === "Circle") {
        center = new Geo.Point(0, 0);
        radiusPoint = new Geo.Point(15, 0);
        Render.drawPoint(canvas, center);
        Render.drawPoint(canvas, radiusPoint);
        return Render.drawCircle(canvas, center, radiusPoint);
      } else if (toolName === "RotationWreath") {
        p1 = new Geo.Point(0, 0);
        return Render.drawRotationWreath(canvas, p1, 12);
      }
    };

    Editor.prototype.palettePointerDown = function(e) {
      var toolEl, toolName;
      toolEl = e.target.closest(".palette-tool");
      if (toolEl == null) {
        return;
      }
      toolName = toolEl.getAttribute("data-tool");
      return this.selectTool(toolName);
    };

    Editor.prototype.selectTool = function(toolName) {
      var palette, toolEl, _i, _len, _ref;
      this.tool = new EditorTool[toolName](this);
      palette = document.querySelector("#palette");
      _ref = palette.querySelectorAll(".palette-tool");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        toolEl = _ref[_i];
        toolEl.removeAttribute("data-selected");
      }
      toolEl = palette.querySelector(".palette-tool[data-tool='" + toolName + "']");
      return toolEl.setAttribute("data-selected", "");
    };

    Editor.prototype.setupCanvas = function() {
      var canvasEl;
      canvasEl = document.getElementById("c");
      this.canvas = new Canvas(canvasEl);
      window.addEventListener("resize", this.resize);
      this.resize();
      canvasEl.addEventListener("pointerdown", this.canvasPointerDown);
      canvasEl.addEventListener("pointermove", this.canvasPointerMove);
      canvasEl.addEventListener("pointerup", this.canvasPointerUp);
      canvasEl.addEventListener("pointerleave", this.canvasPointerLeave);
      return canvasEl.addEventListener("pointercancel", this.canvasPointerLeave);
    };

    Editor.prototype.resize = function() {
      this.canvas.setupSize();
      return this.refresh();
    };

    Editor.prototype.workspacePosition = function(e) {
      var pointerPosition, workspacePosition;
      pointerPosition = new Geo.Point(e.clientX, e.clientY);
      return workspacePosition = this.canvas.browserToWorkspace(pointerPosition);
    };

    Editor.prototype.canvasPointerDown = function(e) {
      e.preventDefault();
      this.tool.pointerDown(e);
      return this.refresh();
    };

    Editor.prototype.canvasPointerMove = function(e) {
      this.doMove(e);
      this.tool.pointerMove(e);
      return this.refresh();
    };

    Editor.prototype.canvasPointerUp = function(e) {
      this.doMove(e, true);
      this.endMove();
      this.tool.pointerUp(e);
      return this.refresh();
    };

    Editor.prototype.canvasPointerLeave = function(e) {
      this.tool.pointerLeave(e);
      return this.refresh();
    };

    Editor.prototype.refresh = function() {
      Render.render(this.canvas, this);
      return this.layerManager.writeToDOM();
    };

    Editor.prototype.startMove = function(e, pointRef) {
      var path, point;
      if (!pointRef) {
        point = new Model.Point(new Geo.Point(0, 0));
        path = new Ref.Path([]);
        pointRef = new Ref(path, point);
      }
      this.movingPointRef = pointRef;
      this.doMove(e);
      return pointRef;
    };

    Editor.prototype.doMove = function(e, shouldMerge) {
      var moveToPoint, snapRef;
      if (shouldMerge == null) {
        shouldMerge = false;
      }
      if (this.movingPointRef) {
        snapRef = this.findSnapRef(e, [this.movingPointRef.object]);
        if (snapRef) {
          if (shouldMerge) {
            return this.mergePointRefs(snapRef, this.movingPointRef);
          } else {
            moveToPoint = snapRef.evaluate();
            return this.movingPointRef.object.point = this.movingPointRef.path.globalToLocal(moveToPoint);
          }
        } else {
          moveToPoint = this.workspacePosition(e);
          return this.movingPointRef.object.point = this.movingPointRef.path.globalToLocal(moveToPoint);
        }
      }
    };

    Editor.prototype.endMove = function() {
      return this.movingPointRef = null;
    };

    Editor.prototype.refsNearPointer = function(e) {
      var canvasPosition, isNear, point, pointRef, pointRefs, pointerPosition, result, _i, _len;
      pointerPosition = new Geo.Point(e.clientX, e.clientY);
      canvasPosition = this.canvas.browserToCanvas(pointerPosition);
      result = [];
      pointRefs = this.model.pointRefs();
      for (_i = 0, _len = pointRefs.length; _i < _len; _i++) {
        pointRef = pointRefs[_i];
        point = pointRef.evaluate();
        isNear = this.canvas.isObjectNearPoint(point, canvasPosition);
        if (isNear) {
          result.push(pointRef);
        }
      }
      return result;
    };

    Editor.prototype.findSnapRef = function(e, excludePoints) {
      var snapRefs,
        _this = this;
      if (excludePoints == null) {
        excludePoints = [];
      }
      snapRefs = this.refsNearPointer(e);
      snapRefs = _.reject(snapRefs, function(snapRef) {
        return _.contains(excludePoints, snapRef.object);
      });
      if (snapRefs.length > 0) {
        return snapRefs[0];
      } else {
        return null;
      }
    };

    Editor.prototype.mergePointRefs = function(anchorPointRef, pointRefToMerge) {
      var findObjects, modelPointRef, modelPointRefs, object, objectToMerge, objects, pathToAppend, _i, _len, _results;
      objectToMerge = pointRefToMerge.object;
      pathToAppend = pointRefToMerge.path.inverse().append(anchorPointRef.path);
      objects = [];
      findObjects = function(object) {
        var childObject, _i, _len, _ref, _results;
        objects.push(object);
        _ref = object.children();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childObject = _ref[_i];
          _results.push(findObjects(childObject));
        }
        return _results;
      };
      findObjects(this.model);
      _results = [];
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        modelPointRefs = object.points();
        modelPointRefs = _.without(modelPointRefs, null);
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = modelPointRefs.length; _j < _len1; _j++) {
            modelPointRef = modelPointRefs[_j];
            if (modelPointRef.object === objectToMerge) {
              modelPointRef.object = anchorPointRef.object;
              _results1.push(modelPointRef.path = modelPointRef.path.append(pathToAppend));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Editor.prototype.removeObject = function(object) {
      var removeObjectFromWreath;
      removeObjectFromWreath = function(object, wreath) {
        var child, _i, _len, _ref, _results;
        wreath.objects = _.without(wreath.objects, object);
        _ref = wreath.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child instanceof Model.Wreath) {
            _results.push(removeObjectFromWreath(object, child));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      return removeObjectFromWreath(object, this.model);
    };

    Editor.prototype.movePointRef = function(pointRef, workspacePosition) {};

    return Editor;

  })();

  EditorTool = {};

  EditorTool.Select = (function() {
    function Select(editor) {
      this.editor = editor;
    }

    Select.prototype.pointerDown = function(e) {
      var found;
      found = this.editor.refsNearPointer(e);
      if (found.length > 0) {
        return this.editor.startMove(e, found[0]);
      }
    };

    Select.prototype.pointerMove = function(e) {};

    Select.prototype.pointerUp = function(e) {};

    Select.prototype.pointerLeave = function(e) {};

    return Select;

  })();

  EditorTool.LineSegment = (function() {
    function LineSegment(editor) {
      this.editor = editor;
      this.provisionalLine = null;
    }

    LineSegment.prototype.pointerDown = function(e) {};

    LineSegment.prototype.pointerMove = function(e) {
      var pointRef;
      if (!this.provisionalLine) {
        pointRef = this.editor.startMove(e);
        this.provisionalLine = new Model.Line(pointRef, null);
        return this.editor.contextWreath.objects.push(this.provisionalLine);
      }
    };

    LineSegment.prototype.pointerUp = function(e) {
      if (this.provisionalLine) {
        if (!this.provisionalLine.end) {
          return this.provisionalLine.end = this.editor.startMove(e);
        } else {
          this.provisionalLine = null;
          return this.editor.endMove();
        }
      }
    };

    LineSegment.prototype.pointerLeave = function(e) {
      if (this.provisionalLine && !this.provisionalLine.end) {
        this.editor.removeObject(this.provisionalLine);
        return this.provisionalLine = null;
      }
    };

    return LineSegment;

  })();

  EditorTool.Circle = (function() {
    function Circle(editor) {
      this.editor = editor;
      this.provisionalCircle = null;
    }

    Circle.prototype.pointerDown = function(e) {};

    Circle.prototype.pointerMove = function(e) {
      var pointRef;
      if (!this.provisionalCircle) {
        pointRef = this.editor.startMove(e);
        this.provisionalCircle = new Model.Circle(pointRef, null);
        return this.editor.contextWreath.objects.push(this.provisionalCircle);
      }
    };

    Circle.prototype.pointerUp = function(e) {
      if (this.provisionalCircle) {
        if (!this.provisionalCircle.radiusPoint) {
          return this.provisionalCircle.radiusPoint = this.editor.startMove(e);
        } else {
          this.provisionalCircle = null;
          return this.editor.endMove();
        }
      }
    };

    Circle.prototype.pointerLeave = function(e) {
      if (this.provisionalCircle && !this.provisionalCircle.radiusPoint) {
        this.editor.removeObject(this.provisionalCircle);
        return this.provisionalCircle = null;
      }
    };

    return Circle;

  })();

  EditorTool.RotationWreath = (function() {
    function RotationWreath(editor) {
      this.editor = editor;
      this.provisionalRotationWreath = null;
    }

    RotationWreath.prototype.pointerDown = function(e) {};

    RotationWreath.prototype.pointerMove = function(e) {
      var pointRef, workspacePosition;
      if (!this.provisionalRotationWreath) {
        pointRef = this.editor.startMove(e);
        this.provisionalRotationWreath = new Model.RotationWreath(pointRef, 12);
        this.editor.contextWreath.objects.push(this.provisionalRotationWreath);
      }
      workspacePosition = this.editor.workspacePosition(e);
      return this.provisionalRotationWreath.center.object.point = workspacePosition;
    };

    RotationWreath.prototype.pointerUp = function(e) {
      if (!this.provisionalRotationWreath) {
        return;
      }
      return this.provisionalRotationWreath = null;
    };

    RotationWreath.prototype.pointerLeave = function(e) {
      if (!this.provisionalRotationWreath) {
        return;
      }
      this.editor.removeObject(this.provisionalRotationWreath);
      return this.provisionalRotationWreath = null;
    };

    return RotationWreath;

  })();

  Geo = {};

  Geo.Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Geo.Line = (function() {
    function Line(start, end) {
      this.start = start;
      this.end = end;
    }

    return Line;

  })();

  LayerManager = (function() {
    function LayerManager(editor) {
      this.editor = editor;
      this.pointerdown = __bind(this.pointerdown, this);
      this.layersEl = document.querySelector("#layers");
      this.domToModel_ = new WeakMap();
      this.modelToDom_ = new WeakMap();
      this.layersEl.addEventListener("pointerdown", this.pointerdown);
    }

    LayerManager.prototype.reset = function() {
      this.domToModel_ = new WeakMap();
      this.modelToDom_ = new WeakMap();
      return this.layersEl.innerHTML = "";
    };

    LayerManager.prototype.pointerdown = function(e) {
      var object, target;
      target = e.target;
      while (!(object = this.domToModel_.get(target))) {
        target = target.parentNode;
      }
      if (object instanceof Model.Wreath) {
        this.editor.contextWreath = object;
        return this.editor.refresh();
      }
    };

    LayerManager.prototype.writeToDOM = function() {
      var contextEl, contextWreath, model, rootEl;
      this.reset();
      model = this.editor.model;
      rootEl = this.objectToEl(model);
      this.layersEl.appendChild(rootEl);
      contextWreath = this.editor.contextWreath;
      contextEl = this.modelToDom_.get(contextWreath);
      return contextEl.classList.add("context");
    };

    LayerManager.prototype.objectToEl = function(object) {
      var el, html;
      html = "<div class=\"layer\">\n  <div class=\"layer-main\">" + object.name + "</div>\n  <div class=\"layer-children\"></div>\n</div>";
      el = makeElFromHTML(html);
      el.querySelector(".layer-children").appendChild(this.childrenToEls(object));
      this.domToModel_.set(el, object);
      this.modelToDom_.set(object, el);
      return el;
    };

    LayerManager.prototype.childrenToEls = function(object) {
      var childEl, childObject, els, _i, _len, _ref;
      els = document.createDocumentFragment();
      if (object instanceof Model.Wreath) {
        _ref = object.objects;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childObject = _ref[_i];
          childEl = this.objectToEl(childObject);
          els.appendChild(childEl);
        }
      }
      return els;
    };

    return LayerManager;

  })();

  /*
  
  Things we want to recurse:
    All the objects (descendants)
    All the refs to objects (e.g. exponentiating it out)
  */


  Model = {};

  Model.Base = (function() {
    function Base() {}

    Base.prototype.name = "";

    Base.prototype.points = function() {
      return [];
    };

    Base.prototype.children = function() {
      return [];
    };

    return Base;

  })();

  Model.Point = (function(_super) {
    __extends(Point, _super);

    Point.prototype.name = "Point";

    function Point(point) {
      this.point = point;
    }

    return Point;

  })(Model.Base);

  Model.Line = (function(_super) {
    __extends(Line, _super);

    Line.prototype.name = "Line";

    Line.prototype.points = function() {
      return [this.start, this.end];
    };

    function Line(start, end) {
      this.start = start;
      this.end = end;
    }

    return Line;

  })(Model.Base);

  Model.Circle = (function(_super) {
    __extends(Circle, _super);

    Circle.prototype.name = "Circle";

    Circle.prototype.points = function() {
      return [this.center, this.radiusPoint];
    };

    function Circle(center, radiusPoint) {
      this.center = center;
      this.radiusPoint = radiusPoint;
    }

    return Circle;

  })(Model.Base);

  Model.Wreath = (function(_super) {
    __extends(Wreath, _super);

    Wreath.prototype.name = "Group";

    Wreath.prototype.children = function() {
      return this.objects;
    };

    function Wreath() {
      this.objects = [];
    }

    Wreath.prototype.ops = function() {
      return [0];
    };

    Wreath.prototype.inverse = function(op) {
      return op;
    };

    Wreath.prototype.perform = function(op, point) {
      return point;
    };

    Wreath.prototype.refs = function() {
      var childRef, childRefs, object, op, path, ref, result, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      result = [];
      _ref = this.ops();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        op = _ref[_i];
        _ref1 = this.objects;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          object = _ref1[_j];
          if (object instanceof Model.Wreath) {
            childRefs = object.refs();
            for (_k = 0, _len2 = childRefs.length; _k < _len2; _k++) {
              childRef = childRefs[_k];
              path = childRef.path.prepend({
                wreath: this,
                op: op
              });
              ref = new Ref(path, childRef.object);
              result.push(ref);
            }
          }
          path = new Ref.Path([
            {
              wreath: this,
              op: op
            }
          ]);
          ref = new Ref(path, object);
          result.push(ref);
        }
      }
      return result;
    };

    Wreath.prototype.pointRefs = function() {
      var add, pointRef, ref, result, _i, _j, _len, _len1, _ref, _ref1;
      result = [];
      add = function(ref, pointRef) {
        var existingRef, path, _i, _len;
        if (pointRef == null) {
          return;
        }
        path = pointRef.path.prepend(ref.path);
        ref = new Ref(path, pointRef.object);
        for (_i = 0, _len = result.length; _i < _len; _i++) {
          existingRef = result[_i];
          if (ref.isEqual(existingRef)) {
            return;
          }
        }
        return result.push(ref);
      };
      _ref = this.refs();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ref = _ref[_i];
        _ref1 = ref.object.points();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          pointRef = _ref1[_j];
          add(ref, pointRef);
        }
      }
      return result;
    };

    return Wreath;

  })(Model.Base);

  Model.RotationWreath = (function(_super) {
    __extends(RotationWreath, _super);

    RotationWreath.prototype.name = "Rotation Group";

    RotationWreath.prototype.points = function() {
      return [this.center];
    };

    function RotationWreath(center, n) {
      this.center = center;
      this.n = n;
      RotationWreath.__super__.constructor.call(this);
    }

    RotationWreath.prototype.ops = function() {
      var _i, _ref, _results;
      return (function() {
        _results = [];
        for (var _i = 0, _ref = this.n; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    };

    RotationWreath.prototype.inverse = function(op) {
      return -op;
    };

    RotationWreath.prototype.perform = function(op, point) {
      var angle, centerPoint, v;
      angle = (op / this.n) * 2 * Math.PI;
      centerPoint = this.center.evaluate();
      v = new Geo.Point(point.x - centerPoint.x, point.y - centerPoint.y);
      v = this.rotate_(angle, v);
      point = new Geo.Point(centerPoint.x + v.x, centerPoint.y + v.y);
      return point;
    };

    RotationWreath.prototype.rotate_ = function(angle, point) {
      var x, y;
      x = Math.cos(angle) * point.x - Math.sin(angle) * point.y;
      y = Math.sin(angle) * point.x + Math.cos(angle) * point.y;
      return new Geo.Point(x, y);
    };

    return RotationWreath;

  })(Model.Wreath);

  /*
  
  A Ref refers to a specific point/line/etc within the context of a series of
  group transformations. For example, a point under the second operation of a
  five-fold rotation wreath.
  
  Every object on the screen has an associated Ref. (We use Wreath.refs() to
  generate all descendant refs.) There can also be Refs that are not drawn on
  the screen (for example a Ref to a point under a group operation for use as
  the endpoint of a line, even though the point does not live under that
  wreath.)
  */


  Ref = (function() {
    function Ref(path, object) {
      this.path = path;
      this.object = object;
    }

    Ref.prototype.evaluate = function() {
      var point;
      if (!(this.object instanceof Model.Point)) {
        throw "Called evaluate on a non-point Ref";
      }
      point = this.object.point;
      return this.path.localToGlobal(point);
    };

    Ref.prototype.isEqual = function(otherRef) {
      return this.path.isEqual(otherRef.path) && this.object === otherRef.object;
    };

    return Ref;

  })();

  Ref.Path = (function() {
    function Path(steps) {
      var step, _i, _len, _ref;
      this.steps = steps != null ? steps : [];
      _ref = this.steps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        step = _ref[_i];
        if (!((step.wreath != null) && (step.op != null))) {
          console.error("bad path", this.steps);
        }
      }
    }

    Path.prototype.prepend = function(steps) {
      steps = this.flexiblyConvertSteps_(steps);
      return new Ref.Path(steps.concat(this.steps));
    };

    Path.prototype.append = function(steps) {
      steps = this.flexiblyConvertSteps_(steps);
      return new Ref.Path(this.steps.concat(steps));
    };

    Path.prototype.flexiblyConvertSteps_ = function(steps) {
      if (steps instanceof Ref.Path) {
        return steps.steps;
      } else if (!_.isArray(steps)) {
        return [steps];
      }
    };

    Path.prototype.inverse = function() {
      var steps;
      steps = this.steps.slice().reverse();
      steps = _.map(steps, function(step) {
        return {
          wreath: step.wreath,
          op: step.wreath.inverse(step.op)
        };
      });
      return new Ref.Path(steps);
    };

    Path.prototype.isEqual = function(otherPath) {
      var i, otherStep, step, _i, _len, _ref;
      _ref = this.steps;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        step = _ref[i];
        otherStep = otherPath.steps[i];
        if (!(otherStep && step.wreath === otherStep.wreath && step.op === otherStep.op)) {
          return false;
        }
      }
      return true;
    };

    Path.prototype.globalToLocal = function(point) {
      var inverseOp, op, step, wreath, _i, _len, _ref;
      _ref = this.steps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        step = _ref[_i];
        wreath = step.wreath, op = step.op;
        inverseOp = wreath.inverse(op);
        point = wreath.perform(inverseOp, point);
      }
      return point;
    };

    Path.prototype.localToGlobal = function(point) {
      var op, step, wreath, _i, _len, _ref;
      _ref = this.steps.slice().reverse();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        step = _ref[_i];
        wreath = step.wreath, op = step.op;
        point = wreath.perform(op, point);
      }
      return point;
    };

    return Path;

  })();

  Render = {};

  Render.render = function(canvas, editor) {
    var center, end, model, object, point, pointRef, radiusPoint, ref, refs, start, _i, _j, _len, _len1, _ref, _results;
    canvas.clear();
    model = editor.model;
    refs = model.refs();
    for (_i = 0, _len = refs.length; _i < _len; _i++) {
      ref = refs[_i];
      object = ref.object;
      if (object instanceof Model.Point) {
        point = ref.evaluate();
        Render.drawPoint(canvas, point);
      } else if (object instanceof Model.Line) {
        if ((object.start != null) && (object.end != null)) {
          start = ref.path.localToGlobal(object.start.evaluate());
          end = ref.path.localToGlobal(object.end.evaluate());
          Render.drawLine(canvas, start, end);
        }
      } else if (object instanceof Model.Circle) {
        if ((object.center != null) && (object.radiusPoint != null)) {
          center = ref.path.localToGlobal(object.center.evaluate());
          radiusPoint = ref.path.localToGlobal(object.radiusPoint.evaluate());
          Render.drawCircle(canvas, center, radiusPoint);
        }
      } else if (object instanceof Model.RotationWreath) {
        center = ref.path.localToGlobal(object.center.evaluate());
        Render.drawRotationWreath(canvas, center, object.n);
      }
    }
    _ref = model.pointRefs();
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      pointRef = _ref[_j];
      point = pointRef.evaluate();
      _results.push(Render.drawPoint(canvas, point));
    }
    return _results;
  };

  Render.drawPoint = function(canvas, point, opts) {
    var ctx;
    if (opts == null) {
      opts = {};
    }
    point = canvas.workspaceToCanvas(point);
    ctx = canvas.ctx;
    ctx.save();
    ctx.beginPath();
    ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = "#333";
    ctx.fill();
    return ctx.restore();
  };

  Render.drawLine = function(canvas, start, end, opts) {
    var ctx;
    if (opts == null) {
      opts = {};
    }
    start = canvas.workspaceToCanvas(start);
    end = canvas.workspaceToCanvas(end);
    ctx = canvas.ctx;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 0.6;
    ctx.stroke();
    return ctx.restore();
  };

  Render.drawCircle = function(canvas, center, radiusPoint, opts) {
    var ctx, radius;
    if (opts == null) {
      opts = {};
    }
    center = canvas.workspaceToCanvas(center);
    radiusPoint = canvas.workspaceToCanvas(radiusPoint);
    radius = (function() {
      var dx, dy;
      dx = center.x - radiusPoint.x;
      dy = center.y - radiusPoint.y;
      return Math.sqrt(dx * dx + dy * dy);
    })();
    ctx = canvas.ctx;
    ctx.save();
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 0.6;
    ctx.stroke();
    return ctx.restore();
  };

  Render.drawRotationWreath = function(canvas, center, n, opts) {
    var color, ctx;
    if (opts == null) {
      opts = {};
    }
    center = canvas.workspaceToCanvas(center);
    ctx = canvas.ctx;
    color = "purple";
    ctx.save();
    ctx.beginPath();
    ctx.arc(center.x, center.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.font = "10px monaco";
    ctx.fillText(n, center.x + 4, center.y - 4);
    return ctx.restore();
  };

  if ((_base = Element.prototype).matches == null) {
    _base.matches = (_ref = (_ref1 = Element.prototype.webkitMatchesSelector) != null ? _ref1 : Element.prototype.mozMatchesSelector) != null ? _ref : Element.prototype.oMatchesSelector;
  }

  Element.prototype.closest = function(selector) {
    var fn, parent;
    if (_.isString(selector)) {
      fn = function(el) {
        return el.matches(selector);
      };
    } else {
      fn = selector;
    }
    if (fn(this)) {
      return this;
    } else {
      parent = this.parentNode;
      if ((parent != null) && parent.nodeType === Node.ELEMENT_NODE) {
        return parent.closest(fn);
      } else {
        return void 0;
      }
    }
  };

  makeElFromHTML = function(html) {
    var dummy;
    dummy = document.createElement("div");
    dummy.innerHTML = html.trim();
    return dummy.firstChild;
  };

}).call(this);
