// Generated by CoffeeScript 1.6.3
(function() {
  var App, Canvas, Geo, Group, Model,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.App = App = (function() {
    function App() {
      this.mouseup = __bind(this.mouseup, this);
      this.mousemove = __bind(this.mousemove, this);
      this.mousedown = __bind(this.mousedown, this);
      this.resize = __bind(this.resize, this);
      var el;
      el = document.getElementById("c");
      this.canvas = new Canvas(el);
      this.model = new Model.Wreath();
      window.addEventListener("resize", this.resize);
      document.addEventListener("mousedown", this.mousedown);
      document.addEventListener("mousemove", this.mousemove);
      document.addEventListener("mouseup", this.mouseup);
      this.resize();
    }

    App.prototype.resize = function() {
      this.canvas.el.width = document.body.clientWidth;
      return this.canvas.el.height = document.body.clientHeight;
    };

    App.prototype.mousedown = function(e) {
      var mousePoint, mousePosition, point;
      e.preventDefault();
      mousePosition = new Geo.Point(e.clientX, e.clientY);
      mousePoint = this.canvas.canvasToWorkspace(mousePosition);
      point = new Model.Point(mousePoint);
      this.model.fibers.push(point);
      return this.draw();
    };

    App.prototype.mousemove = function(e) {};

    App.prototype.mouseup = function(e) {};

    App.prototype.draw = function() {
      var address, addresses, object, _i, _len, _results;
      this.canvas.clear();
      addresses = this.model.addresses();
      _results = [];
      for (_i = 0, _len = addresses.length; _i < _len; _i++) {
        address = addresses[_i];
        object = address.evaluate();
        _results.push(this.canvas.draw(object));
      }
      return _results;
    };

    return App;

  })();

  Canvas = (function() {
    function Canvas(el) {
      this.el = el;
      this.ctx = this.el.getContext("2d");
    }

    Canvas.prototype.width = function() {
      return this.el.width;
    };

    Canvas.prototype.height = function() {
      return this.el.height;
    };

    Canvas.prototype.canvasToWorkspace = function(canvasPoint) {
      var workspacePoint, x, y;
      x = canvasPoint.x - this.width() / 2;
      y = canvasPoint.y - this.height() / 2;
      return workspacePoint = new Geo.Point(x, y);
    };

    Canvas.prototype.workspaceToCanvas = function(workspacePoint) {
      var canvasPoint, x, y;
      x = workspacePoint.x + this.width() / 2;
      y = workspacePoint.y + this.height() / 2;
      return canvasPoint = new Geo.Point(x, y);
    };

    Canvas.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.width(), this.height());
    };

    Canvas.prototype.draw = function(object) {
      if (object instanceof Geo.Point) {
        return this.drawPoint(object);
      } else if (object instanceof Geo.Line) {
        return this.drawLine(object);
      }
    };

    Canvas.prototype.drawPoint = function(point) {
      point = this.workspaceToCanvas(point);
      this.ctx.beginPath();
      this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
      this.ctx.fillStyle = "#000";
      return this.ctx.fill();
    };

    Canvas.prototype.drawLine = function(line) {
      var end, start;
      start = this.workspaceToCanvas(line.start);
      end = this.workspaceToCanvas(line.end);
      this.ctx.beginPath();
      this.ctx.moveTo(start.x, start.y);
      this.ctx.lineTo(end.x, end.y);
      this.ctx.strokeStyle = "#000";
      this.ctx.lineWidth = 1;
      return this.ctx.stroke();
    };

    return Canvas;

  })();

  Geo = {};

  Geo.Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Geo.Line = (function() {
    function Line(start, end) {
      this.start = start;
      this.end = end;
    }

    return Line;

  })();

  Group = (function() {
    function Group(n) {
      this.n = n;
    }

    Group.prototype.apply = function(op, point) {
      var angle;
      angle = 2 * Math.PI * (op / this.n);
      return this.rotate_(angle, point);
    };

    Group.prototype.invert = function(op) {
      return -op;
    };

    Group.prototype.ops = function() {
      var _i, _ref, _results;
      return (function() {
        _results = [];
        for (var _i = 0, _ref = this.n; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    };

    Group.prototype.rotate_ = function(angle, point) {
      var x, y;
      x = Math.cos(angle) * point.x - Math.sin(angle) * point.y;
      y = Math.sin(angle) * point.x + Math.cos(angle) * point.y;
      return new Geo.Point(x, y);
    };

    return Group;

  })();

  Model = {};

  Model.Point = (function() {
    function Point(point) {
      this.point = point;
    }

    return Point;

  })();

  Model.Line = (function() {
    function Line(start, end) {
      this.start = start;
      this.end = end;
    }

    return Line;

  })();

  Model.Wreath = (function() {
    function Wreath() {
      this.control = new Group(12);
      this.fibers = [];
    }

    Wreath.prototype.addresses = function() {
      var fiber, op, result, _i, _j, _len, _len1, _ref, _ref1;
      result = [];
      _ref = this.control.ops();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        op = _ref[_i];
        _ref1 = this.fibers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          fiber = _ref1[_j];
          if (fiber instanceof Model.Wreath) {
            "TODO";
          } else {
            result.push(new Model.Address(fiber, [
              {
                wreath: this,
                op: op
              }
            ]));
          }
        }
      }
      return result;
    };

    return Wreath;

  })();

  Model.Address = (function() {
    function Address(object, path) {
      this.object = object;
      this.path = path != null ? path : [];
    }

    Address.prototype.evaluate = function() {
      var end, point, start, step, _i, _len, _ref;
      if (this.object instanceof Model.Point) {
        point = this.object.point;
        _ref = this.path;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          step = _ref[_i];
          point = step.wreath.control.apply(step.op, point);
        }
        return point;
      } else if (this.object instanceof Model.Line) {
        start = this.object.start.evaluate();
        end = this.object.end.evaluate();
        return new Geo.Line(start, end);
      }
    };

    return Address;

  })();

}).call(this);
